import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as React from "react";
import { useHotkeys } from "react-hotkeys-hook";
import { Controls } from "../icons";
import { Modal } from "../ui";
import config from "../get-config";
import queryString from "query-string";
import { ActionType, ControlType, } from "../../../shared/types";
const getInputType = (type) => {
    switch (type) {
        case ControlType.Boolean:
            return "checkbox";
        case ControlType.Number:
            return "number";
        case ControlType.Range:
            return "range";
        default:
            return "text";
    }
};
const getInputValue = (target, type) => {
    switch (type) {
        case ControlType.Boolean:
            return target.checked;
        case ControlType.Number:
        case ControlType.Range:
            return parseFloat(target.value);
        default:
            return target.value;
    }
};
const coerceString = (value, options) => {
    if (options && options.some((option) => option === Number(value))) {
        return Number(value);
    }
    const isBoolean = value === "true" || value === "false";
    return isBoolean ? (value === "false" ? false : true) : value;
};
export const getQuery = (locationSearch, controlState) => {
    const params = queryString.parse(locationSearch);
    const controls = {};
    // we first need controls being initialized from stories so we know types
    // before taking over from url
    if (Object.keys(controlState).length === 0) {
        return controlState;
    }
    Object.keys(params).forEach((paramKey) => {
        if (paramKey.startsWith("arg-") && controlState[paramKey.split("-")[1]]) {
            const keyParts = paramKey.split("-");
            const argKey = keyParts[1];
            const argValue = params[paramKey];
            const argType = controlState[argKey].type;
            if (argType !== ControlType.Action) {
                let realValue = argValue;
                switch (argType) {
                    case ControlType.String:
                        realValue = decodeURI(argValue);
                        break;
                    case ControlType.Boolean:
                        realValue = argValue === "true";
                        break;
                    case ControlType.Range:
                        realValue = parseFloat(argValue);
                        break;
                    case ControlType.Number:
                        realValue = parseInt(argValue, 10);
                        break;
                    case ControlType.Complex:
                        realValue = JSON.parse(decodeURI(argValue));
                        break;
                    case ControlType.Radio:
                    case ControlType.InlineRadio:
                    case ControlType.Select:
                    case ControlType.Background:
                        realValue = coerceString(decodeURI(argValue), controlState[argKey].options);
                        break;
                    case ControlType.InlineCheck:
                    case ControlType.MultiSelect:
                    case ControlType.Check:
                        realValue = coerceString(JSON.parse(decodeURI(argValue)), controlState[argKey].options);
                        break;
                }
                controls[argKey] = {
                    value: realValue,
                    defaultValue: controlState[argKey].defaultValue,
                    description: controlState[argKey].description,
                    type: controlState[argKey].type,
                };
            }
        }
    });
    return controls;
};
const Control = ({ controlKey, globalState, dispatch, }) => {
    const controlState = globalState.control[controlKey];
    const controlName = globalState.control[controlKey].name || controlKey;
    if (globalState.control[controlKey].type === ControlType.Action) {
        return (_jsxs("tr", { children: [_jsx("td", { children: controlName }), _jsx("td", { children: "action" })] }));
    }
    if (globalState.control[controlKey].type === ControlType.Function) {
        return (_jsxs("tr", { children: [_jsx("td", { children: controlName }), _jsx("td", { children: "function" })] }));
    }
    if (globalState.control[controlKey].type === ControlType.Radio ||
        globalState.control[controlKey].type === ControlType.InlineRadio ||
        (globalState.control[controlKey].type === ControlType.Background &&
            globalState.control[controlKey].options.length < 5)) {
        return (_jsxs("tr", { children: [_jsx("td", { children: controlName }), _jsx("td", { style: globalState.control[controlKey].type === ControlType.InlineRadio
                        ? { display: "flex" }
                        : {}, children: (globalState.control[controlKey].options || []).map((option) => {
                        const value = globalState.control[controlKey].value;
                        const labels = globalState.control[controlKey].labels || {};
                        const label = labels[option] || option;
                        const isChecked = value === option || value === String(option);
                        return (_jsxs("div", { style: {
                                display: "flex",
                                alignItems: "center",
                                ...(globalState.control[controlKey].type ===
                                    ControlType.InlineRadio
                                    ? { paddingRight: "0.5em" }
                                    : {}),
                            }, children: [_jsx("input", { id: `${controlKey}-${String(option)}`, type: "radio", name: controlKey, value: String(option), onChange: () => {
                                        dispatch({
                                            type: ActionType.UpdateControl,
                                            value: {
                                                ...globalState.control,
                                                [controlKey]: {
                                                    ...globalState.control[controlKey],
                                                    value: coerceString(String(option), globalState.control[controlKey].options),
                                                },
                                            },
                                        });
                                    }, checked: isChecked }), _jsx("label", { htmlFor: `${controlKey}-${String(option)}`, children: String(label) })] }, `${String(option)}-${controlKey}`));
                    }) })] }));
    }
    if (globalState.control[controlKey].type === ControlType.Check ||
        globalState.control[controlKey].type === ControlType.InlineCheck ||
        globalState.control[controlKey].type === ControlType.MultiSelect) {
        return (_jsxs("tr", { children: [_jsx("td", { children: controlName }), _jsx("td", { style: globalState.control[controlKey].type === ControlType.InlineCheck
                        ? { display: "flex" }
                        : {}, children: (globalState.control[controlKey].options || []).map((option) => {
                        const value = new Set(globalState.control[controlKey].value);
                        const labels = globalState.control[controlKey].labels || {};
                        const label = labels[option] || option;
                        return (_jsxs("div", { style: {
                                display: "flex",
                                alignItems: "center",
                                ...(globalState.control[controlKey].type ===
                                    ControlType.InlineCheck
                                    ? { paddingRight: "0.5em" }
                                    : {}),
                            }, children: [_jsx("input", { id: `${controlKey}-${String(option)}`, type: "checkbox", name: `${controlKey}-${String(option)}`, value: String(option), checked: value.has(String(option)), onChange: () => {
                                        const newValue = String(option);
                                        if (value.has(newValue)) {
                                            value.delete(newValue);
                                        }
                                        else {
                                            value.add(newValue);
                                        }
                                        dispatch({
                                            type: ActionType.UpdateControl,
                                            value: {
                                                ...globalState.control,
                                                [controlKey]: {
                                                    ...globalState.control[controlKey],
                                                    value: value.size > 0 ? Array.from(value) : undefined,
                                                },
                                            },
                                        });
                                    } }), _jsx("label", { htmlFor: `${controlKey}-${String(option)}`, style: { marginLeft: "0.3em" }, children: String(label) })] }, `${String(option)}-${controlKey}`));
                    }) })] }));
    }
    if (globalState.control[controlKey].type === ControlType.Select ||
        globalState.control[controlKey].type === ControlType.Background) {
        return (_jsxs("tr", { children: [_jsx("td", { children: _jsx("label", { htmlFor: controlKey, children: controlName }) }), _jsx("td", { children: _jsxs("select", { id: controlKey, value: String(globalState.control[controlKey].value), onChange: (e) => {
                            const labels = globalState.control[controlKey].labels || {};
                            const newValue = Object.keys(labels).find((key) => labels[key] === e.target.value) || e.target.value;
                            dispatch({
                                type: ActionType.UpdateControl,
                                value: {
                                    ...globalState.control,
                                    [controlKey]: {
                                        ...globalState.control[controlKey],
                                        value: coerceString(newValue, globalState.control[controlKey].options),
                                    },
                                },
                            });
                        }, children: [_jsx("option", { value: "undefined", disabled: true, children: "Choose option..." }), (globalState.control[controlKey].options || []).map((option) => {
                                const labels = globalState.control[controlKey].labels || {};
                                const label = labels[option] || option;
                                return (_jsx("option", { children: String(label) }, `${option}-${controlKey}`));
                            })] }) })] }));
    }
    if (globalState.control[controlKey].type === ControlType.Complex) {
        let stringValue = "";
        try {
            stringValue = JSON.stringify(globalState.control[controlKey].value);
        }
        catch (e) {
            stringValue = "Object/Array argument must be serializable.";
        }
        return (_jsxs("tr", { children: [_jsx("td", { children: _jsx("label", { htmlFor: controlKey, children: controlName }) }), _jsx("td", { children: _jsx("textarea", { id: controlKey, defaultValue: stringValue, onChange: (e) => {
                            let value = globalState.control[controlKey].value;
                            try {
                                value = JSON.parse(e.target.value);
                            }
                            catch (e) { }
                            dispatch({
                                type: ActionType.UpdateControl,
                                value: {
                                    ...globalState.control,
                                    [controlKey]: {
                                        ...globalState.control[controlKey],
                                        value,
                                    },
                                },
                            });
                        } }) })] }));
    }
    if (controlState.type === ControlType.Range) {
        // the fallback values are based on the standard range validation defaults,
        // see: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range#validation
        const displayMin = controlState.min ?? 0;
        const displayMax = controlState.max ?? 100;
        return (_jsxs("tr", { children: [_jsx("td", { children: _jsx("label", { htmlFor: controlKey, children: controlName }) }), _jsxs("td", { children: [displayMin, _jsx("input", { id: controlKey, type: getInputType(controlState.type), value: controlState.value, min: controlState.min, max: controlState.max, step: controlState.step, onChange: (e) => dispatch({
                                type: ActionType.UpdateControl,
                                value: {
                                    ...globalState.control,
                                    [controlKey]: {
                                        ...controlState,
                                        value: getInputValue(e.target, controlState.type),
                                    },
                                },
                            }) }), controlState.value, " / ", displayMax] })] }));
    }
    return (_jsxs("tr", { children: [_jsx("td", { children: _jsx("label", { htmlFor: controlKey, children: controlName }) }), _jsx("td", { children: _jsx("input", { id: controlKey, type: getInputType(globalState.control[controlKey].type), value: globalState.control[controlKey].value, checked: globalState.control[controlKey].type === ControlType.Boolean &&
                        globalState.control[controlKey].value === true, onChange: (e) => dispatch({
                        type: ActionType.UpdateControl,
                        value: {
                            ...globalState.control,
                            [controlKey]: {
                                ...globalState.control[controlKey],
                                value: getInputValue(e.target, globalState.control[controlKey].type),
                            },
                        },
                    }) }) })] }));
};
export const Button = ({ globalState, dispatch }) => {
    const [open, setOpen] = React.useState(false);
    useHotkeys(config.hotkeys.control, () => setOpen((prev) => !prev), {
        enabled: globalState.hotkeys && config.addons.control.enabled,
    });
    const text = "Explore different versions of this story through controls.";
    const activeControls = Object.keys(globalState.control).filter((key) => JSON.stringify(globalState.control[key].value) !==
        JSON.stringify(globalState.control[key].defaultValue));
    return (_jsx("li", { children: _jsxs("button", { "aria-label": text, title: text, onClick: () => setOpen(true), className: open ? "ladle-active" : "", "data-testid": "addon-control", type: "button", children: [_jsx(Controls, {}), _jsx("span", { className: "ladle-addon-tooltip", children: text }), _jsx("label", { children: "Story Controls" }), activeControls.length ? (_jsx("div", { className: "ladle-badge", children: activeControls.length })) : null, _jsxs(Modal, { isOpen: open, close: () => setOpen(false), label: "Toggle different controls to update the story.", children: [_jsx("table", { className: "ladle-controls-table", children: _jsx("tbody", { children: Object.keys(globalState.control)
                                    .sort()
                                    .map((controlKey) => {
                                    return (_jsx(Control, { globalState: globalState, dispatch: dispatch, controlKey: controlKey }, controlKey));
                                }) }) }), _jsx("button", { onClick: () => {
                                const controls = {};
                                Object.keys(globalState.control).forEach((control) => {
                                    controls[control] = {
                                        ...globalState.control[control],
                                        value: globalState.control[control].defaultValue,
                                    };
                                });
                                dispatch({
                                    type: ActionType.UpdateControl,
                                    value: controls,
                                });
                            }, type: "button", children: "Reset to defaults" })] })] }) }));
};
